# -*- coding: utf-8 -*-
import ast
import json
import re

import redis
import requests
from fastapi import HTTPException


class YaGptInference:
    """
    YaGptInference is a class designed to interact with the Yandex GPT API for generating text completions.
    It maintains session contexts for different chats and facilitates the construction of presentation plans from given texts.
    Args:
            redis_client (redis.client.Redis): redis client for YaGpt chats
    """

    def __init__(self, redis_client: redis.Redis):
        """
        Initializes a new instance of YaGptInference with empty chat and stories length dictionaries.
        Sets the base URL for the Yandex GPT API.
        """
        self.url = "https://llm.api.cloud.yandex.net/foundationModels/v1/completion"
        self.redis_client = redis_client

    def _send_request(self, messages, token):
        """
        Sends a request to the Yandex GPT API to generate a text completion based on the given messages.

        Args:
            messages (list): A list of message dictionaries that form the conversation history or context.
            token (str): The bearer token for authorization with the API.

        Returns:
            str: The text response generated by the model.
        """
        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json; charset=utf-8",
        }
        print("MESSAGES ", messages)
        data = json.dumps(
            {
                "modelUri": "gpt://b1g72uajlds114mlufqi/yandexgpt/latest",
                "completionOptions": {
                    "stream": False,
                    "temperature": 0.6,
                    "maxTokens": "2000",
                },
                "messages": messages,
            }
        )
        response = requests.post(self.url, headers=headers, data=data)
        return response.json()["result"]["alternatives"][0]["message"]["text"]

    def set_context(self, doctext: str, chat_id: str):
        """
        Sets the context for a given chat session, initializing it with system messages that guide the presentation creation process.

        Args:
            doctext (str): The reference document text that will be used for generating the presentation.
            chat_id (str): A unique identifier for the chat session.

        Returns:
            None
        """
        self.redis_client.set(
            chat_id,
            str(
                [
                    {
                        "role": "system",
                        "text": "Ты менеджер по созданию презентаций, твоя задача помогать сотрудникам компании создавать презентации. Ты будешь составлять планы презентаций, а после реализовывать их в тексте презентации, учти, что план обязательно не должен превышать 6 пунктов, иначе презентация будет слишком большой.",
                    },
                    {
                        "role": "system",
                        "text": f"Привет, тебе предстоит составить презентацию на основе этого текста, а также, при необходимости, заменить уже созданный тобой текст, на другой, если пользователь попросит. Учти, что эта презентация - отчетность, поэтому очень важно, чтобы она была точной и лаконичной, не добавляй слишком много текста. А вот и текст опорного документа: {doctext}",
                    },
                ]
            ),
            ex=1800,
        )

    def get_base_presentation(self, message: str, chat_id: str, token: str):
        """
        Generates a base presentation based on the user's message and the chat context.

        Args:
            message (str): The user's request message for generating the presentation.
            chat_id (str): A unique identifier for the chat session.
            token (str): The bearer token for authorization with the API.

        Returns:
            str: A JSON-formatted string representing the generated presentation, including titles and texts for each slide.
        """
        if chat_id not in self.redis_client.keys():
            self.redis_client.set(
                chat_id,
                str(
                    [
                        {
                            "role": "system",
                            "text": "Ты менеджер по созданию презентаций, твоя задача помогать сотрудникам компании создавать презентации. Ты будешь составлять планы презентаций, а после реализовывать их в тексте презентации, учти, что план обязательно не должен превышать 6 пунктов, иначе презентация будет слишком большой.",
                        },
                    ]
                ),
                ex=1800,
            )
        user_message = {
            "role": "user",
            "text": f"Давай начнем, {message}, не забудь, что для каждого слайда нужен текст и заголовок, отправь мне все это в формате JSON с полями text и title, чтобы я смог разделить твой ответ по слайдам, где слайд - элемент списка, у которого есть поля title и text, другие поля не допускаются, а презентация должна быть длиной не более 7 слайдов. Не допускай, чтобы в тексте слайда было пусто или же слишком мало текста, придерживайся 2-3 предложений, также не оставялй заголовки пустыми. Квадратные скобки текста слайдов не используй, это очень важно. Первый слайд будет титульным, поэтому туда нужен только заголовок, поле текст оставь пустым",
        }
        # get chat from redis, update and set
        self.redis_client.set(
            chat_id,
            str(self.redis_client.get(chat_id)[:-1] + ", " + str(user_message) + "]"),
            ex=1800,
        )
        presentation_text = self._send_request(
            ast.literal_eval(self.redis_client.get(chat_id)), token
        )
        try:
            presentation_text_test = presentation_text[
                presentation_text.find("[") + 1 : presentation_text.rfind("]")
            ]
            presentation_text_test = re.sub("[\[]", "<", presentation_text_test)
            presentation_text_test = re.sub("[\]]", ">", presentation_text_test)
            presentation_text_test = "[\n" + presentation_text_test + "\n]"
            json.loads(presentation_text_test)
        except Exception:
            print("something went wrong")
            self.redis_client.set(
                chat_id,
                str(
                    self.redis_client.get(chat_id)[:-1]
                    + ", "
                    + str({"role": "assistant", "text": presentation_text})
                    + "]"
                ),
                ex=1800,
            )
            user_message = {
                "role": "user",
                "text": f"Мы не смогли прочитать перевести твой ответ в формат JSON, перепиши его так, чтобы мы могли его считать, и отправить пользователю, помни, что доускаются только два поля: текст и заголовок, а также то, что у первого слайда поле текст также должно присутствовать, но быть пустым.",
            }
            # get chat from redis, update and set
            self.redis_client.set(
                chat_id,
                str(
                    self.redis_client.get(chat_id)[:-1] + ", " + str(user_message) + "]"
                ),
                ex=1800,
            )
            presentation_text = self._send_request(
                ast.literal_eval(self.redis_client.get(chat_id)), token
            )
        finally:
            print(presentation_text)
            self.redis_client.set(
                chat_id,
                str(
                    self.redis_client.get(chat_id)[:-1]
                    + ", "
                    + str({"role": "assistant", "text": presentation_text})
                    + "]"
                ),
                ex=1800,
            )
            # проводим очистку ответа для парсинга в json
            presentation_text = presentation_text[
                presentation_text.find("[") + 1 : presentation_text.rfind("]")
            ]
            presentation_text = re.sub("[\[]", "<", presentation_text)
            presentation_text = re.sub("[\]]", ">", presentation_text)
            presentation_text = "[\n" + presentation_text + "\n]"
            presentation_text = (
                presentation_text[:-1]
                + ",\n"
                + '    {\n     "title": "Спасибо за внимание!",\n       "text": ""\n    }\n]'
            )
        try:
            return json.loads(presentation_text)
        except Exception:
            raise HTTPException(status_code=500, detail="Try again")

    def rewrite_text(self, message: str, old_message: str, chat_id: str, token: str):
        """
        Rewrites a previously generated text based on user feedback.

        Args:
            message (str): The user's requirements for the rewritten text.
            old_message (str): The original text that needs to be rewritten.
            chat_id (str): A unique identifier for the chat session.
            token (str): The bearer token for authorization with the API.

        Returns:
            str: The newly generated text that meets the user's requirements.
        """
        user_message = {
            "role": "user",
            "text": f"Пользователю не подошел предложенный тобой текст: {old_message}, вот его требования для нового текста слайда: {message}, не забудь, что текст не долежн быть не больше 2 предложений, а также не должен иметь лишних комментариев, чтобы легко встроиться в презентацию.",
        }
        self.redis_client.set(
            chat_id,
            str(self.redis_client.get(chat_id)[:-1] + ", " + str(user_message) + "]"),
            ex=1800,
        )
        new_text = self._send_request(
            ast.literal_eval(self.redis_client.get(chat_id)), token
        )
        self.redis_client.set(
            chat_id,
            str(
                self.redis_client.get(chat_id)[:-1]
                + ", "
                + str({"role": "assistant", "text": new_text})
                + "]"
            ),
            ex=1800,
        )
        return new_text
